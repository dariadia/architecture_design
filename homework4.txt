1. Найдите в коде паттерн Фабричный метод (Factory Method) и объясните,
для чего он был применён.
а) BillingInterface: BankTransfer или Card, оба выполняют pay. Интерфейс Оплаты объявляет поведение (для оплаты) различными способами, выбор за клиентом. checkoutProcess (из Order>Basket) может работать с любым из BillingInterface, так как он не зависит от конкретных классов, а зависит от интерфейса.
Почему применён – позволяет переопределять типы создаваемого способа оплаты в зависимости от выбора клиента. Может пригодится, если добавим новый метод оплаты, например Paypal, тогда он тоже будет выполнять BillingInterface
б) CommunicationInterface для Email и Sms тоже самое. 

2. Примените паттерн Прототип (Prototype) для создания набора Entity в методах
search() и fetchAll() класса Model\Repository\Product.


3. В методе checkout() класса Service\Order\Basket применить паттерн Строитель
(Builder). Написать самим класс строителя (BasketBuilder), в методе checkout()
вызывать сеттер-методы Строителя, а checkoutProcess() выделить в отдельный
класс, в который передать Строителя.

4. Прочитать информацию про внедрение зависимостей.
Документация (к проекту уже подключена библиотека symfony/dependency-injection):
https://symfony.com/doc/current/components/dependency_injection.html
Разобраться для чего это нужно. ++
Позволяет выделить из клиента всю информацию о конкретной реализации, которую он должен использовать (клиент знает что делать, но не как точно это делать). Помогает изолировать клиента от влияния изменений в этих реализациях (например, добавляем новый способ оплаты, или ДБ для хранения чего-то). 
+ повторное использование
+ тестировать
+ проще фиксить